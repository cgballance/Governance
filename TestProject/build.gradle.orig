plugins {
	id 'java' // so that we can use 'implementation', 'testImplementation' for dependencies
}

repositories {
	mavenCentral()
}

dependencies {
	implementation (group: 'com.webforged.enforcer', name: 'GradleGovernancePlugin', version: '1.0')
	implementation (group: 'commons-logging', name: 'commons-logging', version: '1.1.1')
	implementation (group: 'org.infinispan', name: 'infinispan-core', version: '7.2.0.Beta2')
	implementation (group: 'org.springframework', name: 'spring-core', version: '5.3.4')
}

project.ext.acronym = 'DIY'
project.ext.group = 'org.webforged.enforcer'
project.ext.name = 'gradle.worm'
project.ext.version = '0.0.1'

apply plugin: GradleGovernancePlugin

project.configurations.implementation {
	StringBuilder messages = new StringBuilder()
    Configuration configuration = project.configurations.implementation
    for( dependency in configuration.getDependencies() ) {
		def key = dependency.getGroup() + ":" + dependency.getName() + ":" + dependency.getVersion()
		println "Check allowance to use: " + key
		if( dependency.getGroup() == 'org.infinispan' ) {
			messages.append( "Unauthorized to use: " + dependency.getGroup() + ":" + dependency.getName() + ":" + dependency.getVersion() + "\n" ) ;
		}
    }
	if( messages.length() > 0 ) {
		throw new StopActionException( messages.toString() ) ;
	}
}


/**
You can use a task like this to check the database for authorized libraries for an application.  This
way has the downside that it has already built the application(cpu cycles used) prior to being notfied that
the project has disallowed usage(s).

task resolveDependency {
	StringBuilder messages = new StringBuilder()
	def listener = new DependencyResolutionListener() {
		void beforeResolve(ResolvableDependencies dependencies) {
			println "beforeResolve: " + dependencies
			dependencies.dependencies.each {
				println "will resolve dependency: " + it
				if( it.group == 'org.infinispan' ) {
					messages.append( "Unauthorized to use: " + it.group + ":" + it.name + ":" + it.version + "\n" ) ;
				}
			}
		}
		void afterResolve(ResolvableDependencies dependencies) {
			println "afterResolve: " + dependencies
			dependencies.dependencies.each {
				println "resolved dependency: " + it
			}
		}
	}
	project.getGradle().addListener(listener)
	def blistener = new BuildListener() {
		void beforeSettings(Settings settings ) {
			println "Build listener beforeSettings"
		}
		void buildFinished(BuildResult result) {
			println "Build listener buildFinished"
			if( messages.length() > 0 ) {
				throw new StopActionException( messages.toString() ) ;
			}
		}
		void projectsEvaluated(Gradle gradle) {
			println "Build listener projectsEvaluated"
		}
		void projectsLoaded(Gradle gradle) {
			println "Build listener projectsLoaded"
		}
		void settingsEvaluated(Settings settings) {
				println "Build listener settings evaled"
		}
	}
	project.getGradle().addListener(blistener)
}
**/

